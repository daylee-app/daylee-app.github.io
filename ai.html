<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Daylee Scedula</title>
  <meta name="description" content="Your Daylee calendar – see your events, weather, and more.">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <link rel="icon" href="/uploads/images/favicon.png" type="image/png">
  <link href="/css/home.css" rel="stylesheet">
  <link href="/css/main.css" rel="stylesheet">
  <style>
    body { font-family: Arial, sans-serif; background: #f5f5f5; margin: 0; padding: 0; }
    .container { max-width: 500px; margin: 40px auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #0001; padding: 24px; }
    h1 { text-align: center; }
    #chat { height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 12px; background: #fafafa; margin-bottom: 16px; }
    .user { color: #1976d2; margin-bottom: 8px; }
    .ai { color: #388e3c; margin-bottom: 8px; }
    #input-area { display: flex; gap: 8px; }
    #user-input { flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #ccc; }
    #send-btn { padding: 8px 16px; border: none; border-radius: 4px; background: #1976d2; color: #fff; cursor: pointer; }
    #send-btn:hover { background: #1565c0; }
    .directions-link { word-break: break-all; }
  </style>
</head>
<body>
  <a href="/dashboard" id="top-link">< Dashboard</a>
    <header>
     <img src="/uploads/images/daylee.png" alt="Daylee Logo" style="width:64px;height:64px;border-radius:16px;box-shadow:0 4px 16px #2563eb22;margin-bottom:0.5rem;animation: popIn 1.2s cubic-bezier(.4,0,0.2,1) 0s;">
     <br>
    <span class="logo">daylee</span>
    <div class="subtitle">Schedula - Your Schedule Assistant</div>
  </header>
  <div class="container">
    <h1>AI Calendar Assistant</h1>
    <div id="chat"></div>
    <form id="input-area">
      <input type="text" id="user-input" placeholder="Ask about your calendar, weather, location, or directions..." autocomplete="off" required />
      <button type="submit" id="send-btn">Send</button>
    </form>
  </div>
  <script>
    // --- Calendar Logic ---
    function loadEvents() {
      return JSON.parse(localStorage.getItem('dayleeEvents') || '[]');
    }
    function saveEvents(events) {
      localStorage.setItem('dayleeEvents', JSON.stringify(events));
    }
    function getNextDateForWeekday(weekday) {
      const days = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
      const today = new Date();
      const todayIdx = today.getDay();
      const targetIdx = days.indexOf(weekday.toLowerCase());
      let diff = targetIdx - todayIdx;
      if (diff < 0) diff += 7;
      if (diff === 0) diff = 7;
      const result = new Date(today);
      result.setDate(today.getDate() + diff);
      return result.toISOString().slice(0,10);
    }
    function formatEventsForDate(date, weekday) {
      const events = loadEvents().filter(e => e.date === date);
      if (!events.length) return "No events scheduled for " + weekday + ".";
      return "Events for " + weekday + ":<br>" + events.map(e => "- " + (e.time || "All day") + ": " + e.title).join("<br>");
    }
    function formatAllEvents() {
      const events = loadEvents();
      if (!events.length) return "No events scheduled.";
      const grouped = {};
      events.forEach(e => {
        if (!grouped[e.date]) grouped[e.date] = [];
        grouped[e.date].push(e);
      });
      let out = "";
      Object.keys(grouped).sort().forEach(date => {
        const d = new Date(date);
        const weekday = d.toLocaleDateString(undefined, { weekday: 'long' });
        out += `<b>${weekday} (${date}):</b><br>`;
        out += grouped[date].map(e => "- " + (e.time || "All day") + ": " + e.title).join("<br>") + "<br>";
      });
      return out;
    }

    // --- Weather Logic ---
    async function getWeatherString() {
      return new Promise((resolve) => {
        if (!navigator.geolocation) {
          resolve("Geolocation is not supported by your browser.");
          return;
        }
        navigator.geolocation.getCurrentPosition(
          pos => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,apparent_temperature,precipitation,weathercode,cloudcover,windspeed_10m,winddirection_10m,relativehumidity_2m&daily=temperature_2m_max,temperature_2m_min,sunrise,sunset,precipitation_sum,weathercode&temperature_unit=auto&windspeed_unit=auto&precipitation_unit=mm&timezone=auto`)
              .then(res => res.json())
              .then(data => {
                if (!data.current_weather) {
                  resolve("Weather data not available for your location.");
                  return;
                }
                const w = data.current_weather;
                const daily = data.daily;
                const weatherCodes = {
                  0: "Clear sky", 1: "Mainly clear", 2: "Partly cloudy", 3: "Overcast",
                  45: "Fog", 48: "Depositing rime fog", 51: "Light drizzle", 53: "Drizzle", 55: "Dense drizzle",
                  56: "Freezing drizzle", 57: "Freezing drizzle", 61: "Slight rain", 63: "Rain", 65: "Heavy rain",
                  66: "Freezing rain", 67: "Freezing rain", 71: "Slight snow", 73: "Snow", 75: "Heavy snow",
                  77: "Snow grains", 80: "Rain showers", 81: "Rain showers", 82: "Violent rain showers",
                  85: "Snow showers", 86: "Heavy snow showers", 95: "Thunderstorm", 96: "Thunderstorm hail", 99: "Thunderstorm hail"
                };
                resolve(
                  `Current weather: <b>${weatherCodes[w.weathercode] || "Unknown"}</b><br>
                  Temperature: ${w.temperature}°C<br>
                  Wind: ${w.windspeed} km/h<br>
                  Cloud Cover: ${data.hourly.cloudcover[0]}%<br>
                  Humidity: ${data.hourly.relativehumidity_2m[0]}%<br>
                  Today's High: ${daily.temperature_2m_max[0]}°C, Low: ${daily.temperature_2m_min[0]}°C`
                );
              })
              .catch(() => resolve("Could not fetch weather data."));
          },
          () => resolve("Could not get your location for weather. Please allow location access.")
        );
      });
    }

    // --- Location Logic ---
    async function getLocationString() {
      return new Promise((resolve) => {
        if (!navigator.geolocation) {
          resolve("Geolocation is not supported by your browser.");
          return;
        }
        navigator.geolocation.getCurrentPosition(
          pos => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`)
              .then(res => res.json())
              .then(data => {
                if (data && data.display_name) {
                  resolve(`Your current location: <b>${data.display_name}</b>`);
                } else {
                  resolve(`Your coordinates: ${lat.toFixed(5)}, ${lon.toFixed(5)}`);
                }
              })
              .catch(() => resolve(`Your coordinates: ${lat.toFixed(5)}, ${lon.toFixed(5)}`));
          },
          () => resolve("Could not get your location. Please allow location access.")
        );
      });
    }

    // --- Directions Logic ---
    async function getDirectionsString(query) {
      // Try to get user location
      return new Promise((resolve) => {
        if (!navigator.geolocation) {
          resolve("Geolocation is not supported by your browser.");
          return;
        }
        navigator.geolocation.getCurrentPosition(
          async pos => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            // If query looks like an address (has numbers or commas), just use it
            if (/\d+|,/.test(query)) {
              const url = `https://www.google.com/maps/dir/?api=1&origin=${lat},${lon}&destination=${encodeURIComponent(query)}`;
              resolve(`Directions: <a class="directions-link" href="${url}" target="_blank">${query}</a>`);
              return;
            }
            // Otherwise, search for the nearest place using Nominatim
            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1&viewbox=${lon-0.1},${lat+0.1},${lon+0.1},${lat-0.1}&bounded=1`)
              .then(res => res.json())
              .then(results => {
                if (results && results.length > 0) {
                  const place = results[0];
                  const url = `https://www.google.com/maps/dir/?api=1&origin=${lat},${lon}&destination=${place.lat},${place.lon}`;
                  resolve(`Directions to nearest <b>${query}</b>: <a class="directions-link" href="${url}" target="_blank">${place.display_name}</a>`);
                } else {
                  resolve("Sorry, I couldn't find that place nearby.");
                }
              })
              .catch(() => resolve("Sorry, I couldn't search for that place."));
          },
          () => resolve("Could not get your location for directions. Please allow location access.")
        );
      });
    }

    // --- Activity Suggestion State ---
    let lastSuggestedActivity = null;

    // --- Input Parsing ---
    function parseInput(input) {
      input = input.toLowerCase();

      // Add event
      let addMatch = input.match(/add (?:an?|the)?\s*(.*?)\s*(?:appointment|event)?\s*(?:at|@)?\s*([0-9:apm ]+)?\s*(?:on)?\s*(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/);
      if (addMatch) {
        return {
          intent: 'add',
          title: addMatch[1] ? addMatch[1].trim() : 'Event',
          time: addMatch[2] ? addMatch[2].trim() : '',
          day: addMatch[3]
        };
      }

      // "Can I do X at TIME on DAY"
      let canDoMatch = input.match(/can i (.+?) (?:at\s*([0-9:apm ]+))?\s*(?:on)?\s*(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/);
      if (canDoMatch) {
        return {
          intent: 'can_do',
          activity: canDoMatch[1].trim(),
          time: canDoMatch[2] ? canDoMatch[2].trim() : '',
          day: canDoMatch[3]
        };
      }

      // "When can I do X on DAY" or "When can I do X on DAY between TIME1 and TIME2"
      let whenCanDoMatch = input.match(/when can i (.+?) on (monday|tuesday|wednesday|thursday|friday|saturday|sunday)(?: (?:between|inbetween) ([0-9:apm ]+) and ([0-9:apm ]+))?/);
      if (whenCanDoMatch) {
        return {
          intent: 'when_can_do',
          activity: whenCanDoMatch[1].trim(),
          day: whenCanDoMatch[2],
          start: whenCanDoMatch[3] ? whenCanDoMatch[3].trim() : null,
          end: whenCanDoMatch[4] ? whenCanDoMatch[4].trim() : null
        };
      }

      // "Add that to my calendar"
      if (input.match(/add that to (my )?calendar/)) {
        return { intent: 'add_last_suggestion' };
      }

      // Delete event
      let delMatch = input.match(/delete (?:the )?(.*?)(?: (?:on|at) )?([0-9:apm ]+)?(?: on )?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)?/);
      if (delMatch && (delMatch[1] || delMatch[2] || delMatch[3])) {
        return {
          intent: 'delete',
          title: delMatch[1] ? delMatch[1].trim() : null,
          time: delMatch[2] ? delMatch[2].trim() : null,
          day: delMatch[3]
        };
      }

      // Calendar query
      let queryMatch = input.match(
        /(can i|do i|am i|is there|what's|what is|show|list|anything|free|available|busy|plans?|scheduled?|events?).*?(on|for)?\s*(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/
      );
      if (queryMatch) {
        return {
          intent: 'query',
          day: queryMatch[3]
        };
      }

      // List all events
      if (input.match(/all events|everything|full calendar|show calendar|list all|what's my week|what's my schedule/)) {
        return { intent: 'list' };
      }
      // Weather
      if (input.match(/weather|temperature|forecast|rain|sunny|cloudy|wind|humidity/)) {
        return { intent: 'weather' };
      }
      // Location
      if (input.match(/where am i|my location|current location|where are we|what is my address|what's my address|where is this/)) {
        return { intent: 'location' };
      }
      // Directions (address or place/company)
      if (input.match(/(directions|how do i get to|navigate|route|way to|get to|take me to|go to|drive to|walk to|show me the way to|find directions to)\s+(.+)/)) {
        const match = input.match(/(directions|how do i get to|navigate|route|way to|get to|take me to|go to|drive to|walk to|show me the way to|find directions to)\s+(.+)/);
        return { intent: 'directions', query: match[2].trim() };
      }
      return { intent: 'unknown' };
    }

    // --- AI Response Logic ---
    async function aiRespond(input) {
      const parsed = parseInput(input);

      // Add event
      if (parsed.intent === 'add') {
        const date = getNextDateForWeekday(parsed.day);
        const events = loadEvents();
        events.push({
          title: parsed.title,
          date: date,
          time: parsed.time,
          desc: ''
        });
        saveEvents(events);
        lastSuggestedActivity = null;
        return `Added "${parsed.title}"${parsed.time ? ' at ' + parsed.time : ''} on ${parsed.day} (${date}).`;
      }

      // Can I do X at TIME on DAY
      if (parsed.intent === 'can_do') {
        const date = getNextDateForWeekday(parsed.day);
        const events = loadEvents().filter(e => e.date === date);
        let busy = false;
        let conflictEvent = null;
        if (parsed.time) {
          for (const e of events) {
            if (e.time && e.time.replace(/\s/g,'') === parsed.time.replace(/\s/g,'')) {
              busy = true;
              conflictEvent = e;
              break;
            }
          }
        }
        if (busy) {
          lastSuggestedActivity = null;
          return `No, you already have "${conflictEvent.title}" at ${parsed.time} on ${parsed.day}.`;
        } else {
          // Add the activity as an event
          events.push({
            title: parsed.activity,
            date: date,
            time: parsed.time,
            desc: ''
          });
          saveEvents([...loadEvents().filter(e => e.date !== date), ...events]);
          lastSuggestedActivity = null;
          return `Yes, you are free at ${parsed.time ? parsed.time : "that time"} on ${parsed.day}. I've added "${parsed.activity}" to your calendar.`;
        }
      }

      // When can I do X on DAY (optionally between times)
      if (parsed.intent === 'when_can_do') {
        const date = getNextDateForWeekday(parsed.day);
        const events = loadEvents().filter(e => e.date === date && e.time);
        // Build a list of busy times
        const busyTimes = events.map(e => e.time.replace(/\s/g,''));
        // Build a list of possible times (every 30 min between 8:00 and 20:00 or user range)
        function parseTime(t) {
          t = t.trim().toLowerCase();
          let [h, m] = t.split(':');
          m = m ? parseInt(m) : 0;
          if (t.includes('pm') && parseInt(h) < 12) h = parseInt(h) + 12;
          else h = parseInt(h);
          return h * 60 + m;
        }
        let start = parsed.start ? parseTime(parsed.start) : 8 * 60;
        let end = parsed.end ? parseTime(parsed.end) : 20 * 60;
        let found = null;
        for (let mins = start; mins <= end; mins += 30) {
          let hour = Math.floor(mins / 60);
          let min = mins % 60;
          let tstr = `${hour}:${min.toString().padStart(2, '0')}`;
          if (!busyTimes.includes(tstr)) {
            found = tstr;
            break;
          }
        }
        if (found) {
          lastSuggestedActivity = {
            title: parsed.activity,
            date: date,
            time: found,
            desc: ''
          };
          return `You are free to "${parsed.activity}" at ${found} on ${parsed.day}. Say "add that to my calendar" to save it.`;
        } else {
          lastSuggestedActivity = null;
          return "Sorry, you are busy during that time range.";
        }
      }

      // Add last suggestion
      if (parsed.intent === 'add_last_suggestion') {
        if (lastSuggestedActivity) {
          const events = loadEvents();
          events.push(lastSuggestedActivity);
          saveEvents(events);
          const msg = `Added "${lastSuggestedActivity.title}" at ${lastSuggestedActivity.time} on ${new Date(lastSuggestedActivity.date).toLocaleDateString(undefined, { weekday: 'long' })}.`;
          lastSuggestedActivity = null;
          return msg;
        } else {
          return "Sorry, there's nothing to add right now.";
        }
      }

      // Delete event
      if (parsed.intent === 'delete') {
        let events = loadEvents();
        let before = events.length;
        events = events.filter(e => {
          let match = true;
          if (parsed.title) match = match && (!e.title || !e.title.toLowerCase().includes(parsed.title));
          if (parsed.time) match = match && (!e.time || e.time.replace(/\s/g,'') !== parsed.time.replace(/\s/g,''));
          if (parsed.day) {
            const eventDay = new Date(e.date).toLocaleDateString(undefined, { weekday: 'long' }).toLowerCase();
            match = match && eventDay !== parsed.day;
          }
          return !match;
        });
        saveEvents(events);
        if (events.length < before) {
          return "Event deleted.";
        } else {
          return "No matching event found to delete.";
        }
      }

      // Calendar query
      if (parsed.intent === 'query') {
        const date = getNextDateForWeekday(parsed.day);
        return formatEventsForDate(date, parsed.day);
      }
      if (parsed.intent === 'list') {
        return formatAllEvents();
      }
      if (parsed.intent === 'weather') {
        return await getWeatherString();
      }
      if (parsed.intent === 'location') {
        return await getLocationString();
      }
      if (parsed.intent === 'directions') {
        return await getDirectionsString(parsed.query);
      }
      return "I'm here to help you manage your schedule and answer questions about your events, weather, location, or directions. Try asking something like 'What's on my calendar?', 'Will it rain tomorrow?', or 'Directions to Starbucks'.";
    }

    // --- UI Logic ---
    const chat = document.getElementById('chat');
    const form = document.getElementById('input-area');
    const userInput = document.getElementById('user-input');

    function appendMessage(sender, text) {
      const div = document.createElement('div');
      div.className = sender;
      div.innerHTML = `<strong>${sender === 'user' ? 'You' : 'AI'}:</strong> ${text}`;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    form.addEventListener('submit', async function(e) {
      e.preventDefault();
      const input = userInput.value.trim();
      if (!input) return;
      appendMessage('user', input);
      appendMessage('ai', '<em>Thinking…</em>');
      const response = await aiRespond(input);
      chat.lastChild.innerHTML = `<strong>AI:</strong> ${response}`;
      userInput.value = '';
    });

    // Greet on load
    appendMessage('ai', "Hi! Ask me about your calendar, weather, location, or directions. For example:<br>- Add a dentist appointment at 3:00 on Monday<br>- Can I do homework at 5:00 on Friday<br>- When can I do homework on Friday inbetween 10:00 and 2:00<br>- Add that to my calendar<br>- Delete homework at 10:00 on Friday<br>- What's the weather?<br>- Where am I?<br>- Directions to Starbucks or 123 Main St");
  </script>
    <footer>
    Daylee -  Organize your life, your way.
  </footer>
</body>
</html>